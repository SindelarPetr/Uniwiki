@implements IDisposable

<input type="file" @ref="_fileInput" multiple />

@code {
	private ElementReference? _fileInput;

	private readonly IDictionary<string, UploadFile> _files = new Dictionary<string, UploadFile>();
	private DotNetObjectReference<InputFileCallbacks> _callbacksAsNetRef;

	[Inject] IJsInteropService JsInteropService { get; set; }

	[Parameter]
	public EventCallback<UploadFile> OnSelected { get; set; }

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		base.OnAfterRender(firstRender);

		if (!firstRender)
			return;

		var callbacks = new InputFileCallbacks();

		callbacks.OnFileSelected += async file =>
		{
			// Log action
			Console.WriteLine("OnFileSelected: " + file.Id + " >> " + file.Name);
			file.JsInteropService = JsInteropService;
			_files[file.Id] = file;

			await OnSelected.InvokeAsync(file);
		};

		callbacks.OnStart += fileId =>
		{
			Console.WriteLine("OnStart: " + fileId);
			_files[fileId].SetStart();
		};

		callbacks.OnProgress += progressInfo =>
		{
			Console.WriteLine($"OnProgress: { progressInfo.FileId } - { progressInfo.Progress }");
			_files[progressInfo.FileId].SetProgress(progressInfo.Progress);
		};

		callbacks.OnError += fileId =>
		{
			Console.WriteLine($"OnError: { fileId }");
			_files[fileId].SetError();
		};

		callbacks.OnAbort += fileId =>
		{
			Console.WriteLine($"OnAbort: { fileId }");
			_files[fileId].SetAbort();
		};

		callbacks.OnSuccess += successInfo =>
		{
			Console.WriteLine($"OnSuccess: { successInfo.DataForClient }");
			_files[successInfo.FileId].SetSuccess(successInfo.DataForClient);
		};

		_callbacksAsNetRef = DotNetObjectReference.Create(callbacks);

		await JsInteropService.MyInputInit(_fileInput, _callbacksAsNetRef);
	}

	public void Dispose()
	{
		_callbacksAsNetRef?.Dispose();
	}

}
